# -*- coding: utf-8 -*-
"""customer churn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZVa_C2GpDeFjKEgOKqQPPgWbPwzku1Zk
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import numpy as np

df = pd.read_csv('customer_churn.csv')
df.sample(5)

df.drop('customerID', axis = 'columns', inplace = True)

df[pd.to_numeric(df.TotalCharges, errors = 'coerce').isnull()]

df1 = df[df.TotalCharges!= ' ']
df1.shape

df1.dtypes

df1.TotalCharges = pd.to_numeric(df1.TotalCharges)

df1.TotalCharges.dtypes

"""to calculate tenure of those customers who are not churning(leaving)"""

tenure_churn_no = df1[df1.Churn == 'No'].tenure
tenure_churn_yes = df1[df1.Churn == 'Yes'].tenure
plt.hist([tenure_churn_yes, tenure_churn_no], color = ['red', 'yellow'], label = ['Churn_yes', 'Churn_no'])
plt.legend()

mc_churn_no = df1[df1.Churn == 'No'].MonthlyCharges
mc_churn_yes = df1[df1.Churn == 'Yes'].MonthlyCharges
plt.hist([mc_churn_yes, mc_churn_no], color = ['red', 'yellow'], label = ['Churn_yes', 'Churn_no'])
plt.legend()

def print_unique_col_values(df):
  for column in df:
    if df[column].dtypes == 'object':
      print (f'{column}:{df[column].unique()}')

print_unique_col_values(df1)

df1.replace('No internet service', 'No', inplace = True)
df1.replace('No phone service', 'No', inplace = True)

print_unique_col_values(df1)

yes_no_colms = ['Partner', 'Dependents', 'PhoneService', 'MultipleLines', 'OnlineSecurity', 'OnlineBackup', 'DeviceProtection', 'TechSupport', 'StreamingTV', 'StreamingMovies', 'PaperlessBilling', 'Churn']
for col in yes_no_colms:
  df1[col].replace({'Yes':1, 'No':0}, inplace = True)

for col in df1:
  print(f'{col}: {df1[col].unique()}')

df1['gender'].replace({'Female':1, 'Male':0}, inplace = True)

df1['gender'].unique()

df2 = pd.get_dummies(data = df1, columns = ['InternetService', 'Contract', 'PaymentMethod'])
df2.columns

df2.dtypes

col_scale = ['tenure', 'MonthlyCharges', 'TotalCharges']
from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler()
df2[col_scale] = scaler.fit_transform(df2[col_scale])

df2.sample(3)

for col in df2:
  print(f'{col}: {df2[col].unique()}')

X = df2.drop('Churn', axis = 'columns')
y = df2['Churn']

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size = 0.2, random_state = 10)

X_train.shape

X_test.shape

X_train[:10]

len(X_train.columns)

import tensorflow as tf
from tensorflow import keras

model = keras.Sequential([
    keras.layers.Dense(20, input_shape=(26,), activation = 'relu'),
    keras.layers.Dense(1, activation = 'sigmoid')                          
])

model.compile(optimizer = 'adam',
              loss = 'binary_crossentropy',
              metrics = ['accuracy'])

model.fit(X_train, y_train, epochs = 100)

model.evaluate(X_test, y_test)

y_predict = model.predict(X_test)
y_predict[:5]

y_test[:15]

y_pred = []
for ele in y_predict:
  if ele > 0.5:
    y_pred.append(1)
  else:
    y_pred.append(0)

y_pred[:15]

from sklearn.metrics import confusion_matrix, classification_report
print(classification_report(y_test, y_pred))

import seaborn as sn
cm = tf.math.confusion_matrix(labels = y_test, predictions = y_pred)
plt.figure(figsize = (10,7))
sn.heatmap(cm, annot = True, fmt = 'd')
plt.xlabel('Predicted values')
plt.ylabel('Actual values')